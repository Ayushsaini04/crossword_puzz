<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../style.css" />
    <title>Crossword Puzzle</title>
  </head>
  <body>
    <div class="modal"><h2>Please Wait! Generating new crossword...</h2></div>
    <img class="background" src="https://images.pexels.com/photos/1670977/pexels-photo-1670977.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1" alt="background" />
    <br />
    <br />

    <br />
    <div class="app">
      <div class="header">
        <div class="logo">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAllBMVEX43iYAAAD/5Sf/5Cf74Sb/5yjiyiOhkBnp0ST23Cbu1STgyCLYwSH/6Sj33SY8NgnPuSCCdBR8bxNoXRCYiBdsYRDBrR2RghaqmBo3MQi+qh1USw23pBwvKgemlRmSgxbJtB90aBJKQgtfVQ5RSAwhHQWvnRsmIgYUEgMbGASIehVxZRFCOwoQDgN/chNYTw0rJgYYFQNzeWOoAAALWElEQVR4nO1c6XLivBK1tRiviQPGEMckmD2EhMn7v9xVd0vGJEx9VTBVuU71+TEDRnZ01JssdcvzGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8HoMZSSAiGV+um+/HsoqaN0M2lGo9G4KerE07+LpNRBsfC7eB9tot9DUqrNvX8B4/x3cFTy+RI9xOo3cNTztaVzLOZBrLPMC9P64dFeHMXyp3t4G5T6sPSqO926UKWECArLvNY/28XbIIMZsmgS0kZFwI9SViTIYY+lKFOksEB+EC+CsjbIQ4WEld7Q715fjVHOkcBUAD8dD1ath9mOKwVXZXSEr49RPynKHHq/SwTwy0/0LPYxGGA2gM/3vWSoAuj7LDadF8nTpVixB4vUFXxcip/u7jVYO/0ThQt/RZ2m6fx5SP7Hf8+NGHUJHyf986j6DSgYCSoPbc2/N9M0ia5UCplMiOMzUMQZQdo3RVUomcQQjDAmbEvdDQpKeCTYvTaTVhDpnx/r6rVYoxf1PCL4gEFQahUZSHCjnggPqJ5Z/Y7+NOiXECVIaAUqiD6mzjBeTJc4j5k1lZIQIN+QGspyI/tF0FPQayMVgfaWG1nKsOn60WcQavbmvKrXt3mNnJpuN9pTCUrQELTTlxNmiVCabPEY9M+RSlC9UHn6npyJpx+I12JfvLzZWFGVr0h1nvVMQQ0UzEdHmhzqFiS4x/D3bOKFhFjRUdjnvhkgQr6YrpfGCmHlYq48WQOXcWtsSqefxG8Y9c0ACRkoqSQrXBhRxjbynaAiUFXz0vFjfbwNMSkphozaWCMo5Sg7a2JYf1a9XcJQc7QvT4MoPSL8Hn1tlPQuQpyAS0+5QmZLI8oBEf6CvsoPIMFzhuRRB0aU4G/ufrpT/xR6aShFngIPWhlRmXnnsa8u5TK0eV3aSprYpEqFML/ur81dAsy2Z9b+AmL43Qx7DWSYkcOxDAe/jKGxw0/PaakHDD96uQ7zV4ix4RSTpzEBX+18//C7GOK0NFQ4aXuR5FrDPoe/b0D1NBPvO5qWys3XWSmiz/vAGOoLiVHDaKsX2Rf+M8gq7XGMvKNFGnSmJk7gUsbjuTeVRoWH8Q/173boFU5qcGK6BtnBy/yqOxPVuGez720MQeFtjJqCU52aF0XcwfiT2rclJTXuVuwi+NxLc8QgD6++KKnIvOzXtORUxpnWInze4tfEvP2XTz1chjIQKwr2KESYdevaLstsD/ev9GltfA++/e/7KEVcgjpmZIn+JAPP4nbuLR7ALBUse49lH18WxdauQeHeWaHB4OrZiV8T4KUn+/YvU9E3jgqYbZVbKH0AHyNlWixnu91iWGGykIxx48Ios5r7o95NeiS82A/BAsEU/QP6E+NEYb1U0CY+itcvjY5GO79/22u0A1wJR9HfdzPZlMxS2lXEFqCsx97FRtr4TU2/7e6E3+SRFkaG0sSLzYGupUAQU27inonQQBxbivOddTCH4aR4mYz+2K9L2APP4E3Er3snQgDGddiqV+rF/44/JSwS05ZGD7fxPVjWxs3dKfAQcfF6zm9VwXxNeSNU4Ow/n/Z/CRXi/gsl50mRFy7n5M94E+KWmk6Rd9NLCQJUTEF+KoGjgm38JE1DzwQNkJ+IG7+/KkpQivaxZxtlJy0ucc9TWbgnifY7OdHL3O72MHfpNJBQo8PapoEdgl560Q5kPHbO5fhSp2kQQFJUmxU97ef74Tl0crwQKxAvPd0C/gqlg/0Feo/T6PesohrLy1+6+Ze75SDIfof8WphYcZeU9WBSPNfzUOnfYH/fAW7UoM9rwQwGg8FgMBgMBoPBYDAYDAaDweg12k3N9uvlNl8vf7lyocXfUqG/Nv329Et/7looHadVmXpt3lkUhmEc6bN9B6nDvJ4HZxX3OsrLPG6zhJRO5qYFfo2itpDNPMv+3l5UQiXz7q3eXRgGSRhnbR9iuBDE+h9U9ylR2QOsmoR2wtyRSOuPsK0IVVParv98aQ8MUhFt0b/ZVqLC1JMZFD1DztsQnwafDrjHDSlUI7wmgsZuDld2EKlc2vd3byn1QSztDtZyc2uFn4o7B3QV2BUs9SHYRDSZbE+NSrsnT4kmgDmeLtDe1SjMbP+DPRNDH1PdKb1/Ctf06fn+ig51oQSyTh90Z5+uui0JIIZckP08SWvYxf3QluEgzzfmj+xoFCAP+HWQxukUtq43JIixEYm51GDOPvWxDoPNKxKCPDZM3c+gjzWmnSwxZZhSGZdVms4hFewTU8FQvmlewXDk2NjcP6ing+GuJX0lMkPj3tiDAR5AslHEMJdKwm8lDrHp9UhBDoLEIzygnyCldWYuZeUTDssEMi5Mi7tVap8BAqMk6TdocWfomP+xJLrM8C9CbibeDQwfzN1wlE0DAwgFjTEkOSoQeHm9MUKi79a5LJH7b6BPyBB6uSHxQH3M0mU0ZYbiQhDDEdkXilR+uHoLSrxMsLYU64RNZyG1JrelUaDWdutbyRl1HxlKLB2m6iKo8qd0VEyuvpogFoSUrSWrkDrrGNbEUL930wqzGQkRakg6x5SBDCedcwXkFnkZWSxKtGdoUCmslDpVRANtOJmny3BxztDLllbNr4Lp5vu3VAKnpZq0FBRtpM9+hUI88HbvmzbEoDccJ61zFx+uTriIsPoyu8f6DNFYz2SbzUjAwDDraumJIejZ+Np8B+jW6JsZA4cin9cLqhWBUe9UT8KwQyewHME4qdDeT8mmq9b/l1DyBfem2cJ/1MB1oanrnToacLVwwk0ABxDOq8b57w5DEMPj1QxNbx8uytAi6TgNd4/pzBvco2yeUGNP8dJ0CM2riyZgUXpsBgkeELYqv0NRtn+rQFF3osUU+9NlqIyyXBsTQQGHf2c4wb6rzbkMU6tIbQ7N1vbYSAxjKzUGE48FPB80ZZM1JB29PmMISttlOLIR/wvD9dUMQ6x1vcCwDl1UwMMFOsMAiueKmZS4g9Fof1U6hUiNXYOnVDlasvE6y8ww05Z40rHDR2wODJt4ZCzc9qZrh8EtdeJqff73lGOYQ3S0tWjGgt5PbcC1deIT1G+9dx6Yja0Q0XlM0NELE+MTOxAQeop2vFB2zpdmUJtiK/w6DPWE9Ps6gAsfOyGqaIlJhBQtYLAHZBPwyQ0i+kxUMxtGjR/xQ/hKnQDTJhGLrb99xNEHLThS3b69340QnED0IF20gAnxQn9hiB7thgOmYNgGFMakd+jMadTpyTgvqaiRCF/diK5pvgjqd2d+mC6Qsti4qm48dsH6KLQxMj9tdPH+Dq9icEAiNh7CKRt0A8xp8Acdrqmo41rgHMqYt9Cy3MLha14b8aFockXTYJhJPpg3GRFBcew9SFaYiWOhtMgmOCkD0d0nWujg0404Hg5Cn4EVTc/soK4rJbROIPe2blVa0ljGbl4aC0mHvj3e9AZFZ8X5K5zL77A/oCwwp1GvWGEIjWBG7M+W+AZ1wPMvqN5w3KydFGDivhjCv3tnZtA5mtjV/iniqACjyuKI9QvT9s0KtBX+0FJ77vwwwtONh0qKvK04G9KjWoYwFaforOtP16iwIV2m9vjVLb1iuXNaTwTBfvetszqVersXSxi0nBqDdeIZpzAXhCnaieHj7WUaSuST42I1fnazE5UWRYgkNoMit3xU+fC0eGrqU76okvX4cBjVbiVAJ/vV7Dg5VVOqfFBYF6Gmg+6hEjqcvj0dnj7KdhUhLgYl2fxg8AyjWw0QdfBPjvAxU1ChxWnNQknZflDnjc6XUoSUnStQ1HW28tG5vX2k+2oM/+xprqm7BzMcOceRwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDcRH/A5iOjwMAyyuZAAAAAElFTkSuQmCC" alt="Logo">
        </div>
        <h1>
          <span class="title-word">Crossword Puzzle</span>
        </h1>
        <button id="logout-btn">
        LOGOUT
          </button>
      </div>
      <div class="content-container">
        <div class="table-container">
          <div class="controls">
            <div class="diff-select">
              <label id="diff-label" for="difficulty">Difficulty Level</label>
              <select
                name="difficulty"
                id="difficulty"
                class="difficulty-setting"
                size="0"
              >
                <option value="0">Normal</option>
                <option value="1">Expert</option>
              </select>
            </div>
            <div class="buttons">
              <button class="reveal">Reveal</button
              ><button class="new">New</button>
            </div>
          </div>
          <table>
            <tr id="0">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="1">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="2">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="3">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="4">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="5">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="6">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="7">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="8">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
            <tr id="9">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
          </table>
        </div>
        <br />
        <br />
        <div class="message">
          <h2>
            Congratulations, you have completed the crossword! Click 'New' or
            refresh page to generate a new crossword.
          </h2>
        </div>
        <div class="container">
          <div class="across-card"></div>
          <div class="down-card"></div>
        </div>
      </div>
    </div>
    <div class="footer-container example-container">
      <p class="footer-content example-desc" style="color: #fcfafa;">
        This is an elitmus project application.
      </p>
    </div>
    <script
      src="https://code.jquery.com/jquery-3.6.0.min.js"
      integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
      crossorigin="anonymous"
    ></script>
    <script>
      const logoutButton = document.getElementById('logout-btn');

// Attach a click event listener to the button
logoutButton.addEventListener('click', () => {
  // Redirect the user to the login page
  window.location.href = '/';
});
    </script>
    <script type="text/javascript">
    // establish difficulty setting

let difficultySetting = 0;

const difficulty = document.getElementById("difficulty");

if (localStorage.getItem("difficulty") === "1") {
  difficultySetting = 1;
  difficulty.children[1].selected = "selected";
}

// Create grid reference object within grid object

let grid = {};

for (let i = 0; i < 10; i++) {
  grid[`row${i}`] = Array(10);
}

for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 10; j++) {
    $(`[id=${i}]`)[0].cells[
      `${j}`
    ].innerHTML = `<div class="number"></div><div class="contents"></div>`;

    grid[`row${i}`][j] = {
      cell: $(`[id=${i}]`)[0].cells[`${j}`],
      contents: "",
      acrossNumber: "",
      downNumber: "",
      acrossMarked: false,
      downMarked: false,
      opposite: grid[`row${9 - i}`][9 - j],
      above: i > 0 ? grid[`row${i - 1}`][j] : false,
      below: i < 9 ? grid[`row${i + 1}`][j] : false,
      prev: j > 0 ? grid[`row${i}`][j - 1] : false,
      next: j < 9 ? grid[`row${i}`][j + 1] : false,
    };
  }
}

for (let i = 9; i >= 0; i--) {
  for (let j = 9; j >= 0; j--) {
    let currentCell = grid[`row${i}`][j];

    currentCell.opposite = grid[`row${9 - i}`][9 - j];
    currentCell.next = j < 9 ? grid[`row${i}`][j + 1] : false;
    currentCell.below = i < 9 ? grid[`row${i + 1}`][j] : false;
  }
}

// Randomly populate grid symmetrically with black spaces

let blackSqCount = 0;

while (blackSqCount < 80) {
  for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 10; j++) {
      const random = Math.random();

      if (random < 0.7) {
        grid[`row${i}`][j].contents = "#";
        grid[`row${9 - i}`][9 - j].contents = "#";
        grid[`row${i}`][j].cell.style.backgroundColor = "black";
        grid[`row${9 - i}`][9 - j].cell.style.backgroundColor = "black";

        blackSqCount += 2;

        if (blackSqCount > 79) {
          break;
        }
      }
    }
  }
}

// Remove necessary black spaces to make sure there are no blocked off white squares

const preventBlockedWhiteSquares = () => {
  for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 10; j++) {
      const currentCell = grid[`row${i}`][j];

      const blocked =
        (!currentCell.above || currentCell.above.contents === "#") &&
        (!currentCell.below || currentCell.below.contents === "#") &&
        (!currentCell.prev || currentCell.prev.contents === "#") &&
        (!currentCell.next || currentCell.next.contents === "#");

      if (blocked) {
        let surrounding = [];

        currentCell.above &&
          surrounding.push([currentCell.above, currentCell.above.opposite]);
        currentCell.below &&
          surrounding.push([currentCell.below, currentCell.below.opposite]);
        currentCell.prev &&
          surrounding.push([currentCell.prev, currentCell.prev.opposite]);
        currentCell.next &&
          surrounding.push([currentCell.next, currentCell.next.opposite]);

        if (surrounding.length > 0) {
          const index = Math.floor(Math.random() * surrounding.length);
          surrounding[index].forEach((gridItem) => {
            gridItem.cell.style.backgroundColor = "";
            gridItem.contents = "";
          });
        }
      }
    }
  }
};

preventBlockedWhiteSquares();

// change 2 letter word areas into 3 or more letters

let letterCount;

const processTwoLetterWords = (i, j, direction) => {
  const currentCell =
    direction === "across" ? grid[`row${i}`][j] : grid[`row${j}`][i];

  if (currentCell.contents === "") {
    letterCount++;
  }

  if (letterCount === 2 && currentCell.contents === "#") {
    currentCell.contents = "";
    currentCell.opposite.contents = "";
    currentCell.cell.style.backgroundColor = "";
    currentCell.opposite.cell.style.backgroundColor = "";
    letterCount = 0;
  }

  if (currentCell.contents === "#") {
    letterCount = 0;
  }
};

const eliminateTwoLetterWords = () => {
  // processing rows left to right, top to bottom;
  for (let i = 0; i < 5; i++) {
    letterCount = 0;
    for (let j = 0; j < 10; j++) {
      processTwoLetterWords(i, j, "across");
    }
  }

  // processing rows right to left, bottom to top;
  for (let i = 4; i >= 0; i--) {
    letterCount = 0;
    for (let j = 9; j >= 0; j--) {
      processTwoLetterWords(i, j, "across");
    }
  }

  // processing columns top to bottom, left to right;
  for (let j = 0; j < 10; j++) {
    letterCount = 0;
    for (let i = 0; i < 5; i++) {
      processTwoLetterWords(j, i, "down");
    }
  }

  // processing columns bottom to top, right to left;
  for (let j = 9; j >= 0; j--) {
    letterCount = 0;
    for (let i = 4; i >= 0; i--) {
      processTwoLetterWords(j, i, "down");
    }
  }
};

eliminateTwoLetterWords();

// Reduce large blocks of white spaces

for (let i = 1; i < 5; i++) {
  for (let j = 1; j < 9; j++) {
    let currentCell = grid[`row${i}`][j];

    let nineSquare = [
      grid[`row${i - 1}`][j - 1],
      currentCell.above,
      grid[`row${i - 1}`][j + 1],
      grid[`row${i + 1}`][j - 1],
      currentCell.below,
      grid[`row${i + 1}`][j + 1],
      currentCell.prev,
      currentCell.next,
      currentCell,
    ];

    let whiteSquareCount = 0;

    nineSquare.forEach((square) => {
      square.contents !== "#" && whiteSquareCount++;
    });

    if (whiteSquareCount > 7) {
      currentCell.contents = "#";
      currentCell.cell.style.backgroundColor = "black";
      currentCell.opposite.contents = "#";
      currentCell.opposite.cell.style.backgroundColor = "black";
    }
  }
}

// re-run black square clearance to prevent single white squares

preventBlockedWhiteSquares();

// Connect disjointed words

const processDisjointedWords = (rowCount, colCount, direction) => {
  for (let i = 0; i < rowCount; i++) {
    for (let j = 0; j < colCount; j++) {
      if (direction === "across") {
        if (i >= rowCount) {
          break;
        }
      } else {
        if (j >= rowCount) {
          break;
        }
      }

      const currentCell =
        direction === "across" ? grid[`row${i}`][j] : grid[`row${j}`][i];
      if (currentCell.contents !== "#") {
        let count = 1;
        let disconnected = 0;
        let checking = true;
        let blackSquareArr = [];

        while (checking && j < colCount) {
          let currentGridItem;
          let nextGridItem;
          try {
            currentGridItem =
              direction === "across"
                ? grid[`row${i}`][j + (count - 1)]
                : grid[`row${j + (count - 1)}`][i];
            nextGridItem =
              direction === "across"
                ? grid[`row${i}`][j + count]
                : grid[`row${j + count}`][i];
          } catch (err) {
            nextGridItem = undefined;
          }

          let a =
            direction === "across"
              ? currentGridItem.above
              : currentGridItem.prev;
          let b =
            direction === "across"
              ? currentGridItem.below
              : currentGridItem.next;

          if (nextGridItem !== undefined && nextGridItem.contents !== "#") {
            count++;
          } else {
            checking = false;
          }

          if ((!a || a.contents === "#") && b.contents === "#") {
            disconnected++;
            if (a) {
              blackSquareArr.push(a);
            }

            blackSquareArr.push(b);
          }
        }

        if (disconnected === count && count > 1) {
          let targetSquare =
            blackSquareArr[Math.floor(Math.random() * blackSquareArr.length)];
          targetSquare.contents = "";
          targetSquare.cell.style.backgroundColor = "";
          targetSquare.opposite.contents = "";
          targetSquare.opposite.cell.style.backgroundColor = "";
        }
        j += count;
      } else {
        continue;
      }
    }
  }
};

processDisjointedWords(5, 10, "across");
processDisjointedWords(10, 5, "down");

// re-elimainate Two Letter words;

eliminateTwoLetterWords();

// build words object and number grid

let words = {
  across: {},
  down: {},
};

let numberCount = 1;

for (let i = 0; i < 10; i++) {
  let wordAdded = false;

  for (let j = 0; j < 10; j++) {
    let current = grid[`row${i}`][j];

    if (current.contents === "#") {
      current.acrossMarked = true;
      current.downMarked = true;
    }

    if (current.acrossMarked === true && current.downMarked === true) {
      continue;
    }

    //mark across words

    if (!current.acrossMarked) {
      if (grid[`row${i}`][j + 1]) {
        if (grid[`row${i}`][j + 1].contents !== "#") {
          current.cell.children[0].textContent = `${numberCount}`;
          current.acrossNumber = numberCount;

          for (let x = 1; ; x++) {
            let next = grid[`row${i}`][j + x];

            if (!next || next.contents === "#") {
              wordAdded = true;

              let word = {
                word: "",
                ref: [],
                clue: "",
              };

              for (let z = x - 1; z >= 0; z--) {
                word.ref.unshift(grid[`row${i}`][j + z]);
              }

              words.across[`${numberCount}across`] = word;

              break;
            } else {
              next.acrossMarked = true;
              next.acrossNumber = numberCount;
            }
          }
        }
      }
    }

    //mark down words

    if (!current.downMarked) {
      if (grid[`row${i + 1}`]) {
        if (grid[`row${i + 1}`][j].contents !== "#") {
          current.cell.children[0].textContent = `${numberCount}`;
          current.downNumber = numberCount;

          for (let x = 1; ; x++) {
            if (
              !grid[`row${i + x}`] ||
              grid[`row${i + x}`][j].contents === "#"
            ) {
              wordAdded = true;

              let word = {
                word: "",
                ref: [],
                clue: "",
              };

              for (let z = x - 1; z >= 0; z--) {
                word.ref.unshift(grid[`row${i + z}`][j]);
              }

              words.down[`${numberCount}down`] = word;

              break;
            } else {
              let next = grid[`row${i + x}`][j];

              next.downMarked = true;
              next.downNumber = numberCount;
            }
          }
        }
      }
    }

    if (wordAdded) {
      wordAdded = false;
      numberCount++;
    }
  }
}

// Create error handler for build failures

window.addEventListener("unhandledrejection", function (e) {
  window.location.reload();
});

// Call word finder API to discover words for answers

// fill across word spaces with words from API

let complete = false;
let allWords = [];

let disallowed = [
  "bitch",
  "sex",
  "cum",
  "homo",
  "ass",
  "lie",
  "eff",
  "effed",
  "anus",
  "ed",
  "eds",
];

let common = [
  "t",
  "l",
  "d",
  "e",
  "i",
  "s",
  "r",
  "a",
  "o",
  "y",
  "p",
  "c",
  "n",
  "m",
];

const validateWord = (result, comparison) => {
  return (
    !result.defs ||
    allWords.includes(result.word) ||
    result.word.length !== comparison.ref.length ||
    result.word.match(" ") ||
    result.word.match(/[0-9]/) ||
    result.word.match(/["!Â£$%&:-@/<>]/) ||
    disallowed.includes(result.word)
  );
};

const getNewWord = async (searchParams) => {
  let data;
  const response = await fetch(
    `https://api.datamuse.com/words?sp=${searchParams}&md=df`
  );

  try {
    data = await response.json();
  } catch (err) {
    throw new Error("Could not retrieve word(s)");
  }
  return data;
};

const createWordsAndClues = async () => {
  let acrossWords = Object.keys(words.across);

  let bufferAmount = 3;

  for (let i = 0; i < acrossWords.length; i++) {
    let word = words.across[acrossWords[i]];
    let len = word.ref.length;
    let queryParams = "?".repeat(len);
    queryParams = queryParams.split("");

    let count = 0;

    for (let j = 0; j < len; j++) {
      if (word.ref[j].contents !== "") {
        count++;
        queryParams[j] = word.ref[j].contents.toLowerCase();
      }
    }

    if (count === 0) {
      queryParams[Math.floor(Math.random() * queryParams.length)] =
        common[Math.floor(Math.random() * common.length)];
    }

    queryParams = queryParams.join("");

    //Call API

    let shuffledWordList = [];
    let retrievedWordList = [];
    let retrievedWord;

    retrievedWordList = await getNewWord(queryParams);

    if (retrievedWordList.length === 0) {
      throw new Error("No words found");
    }

    if (difficultySetting === 1) {
      shuffledWordList = retrievedWordList.sort((a, b) => {
        return Math.random() > 0.5 ? 1 : -1;
      });
    } else {
      shuffledWordList = retrievedWordList.sort((a, b) => {
        return b.score - a.score;
      });

      let first = shuffledWordList.splice(
        0,
        Math.min(shuffledWordList.length, bufferAmount)
      );

      randomFirst = first.sort((a, b) => {
        return Math.random() > 0.5 ? 1 : -1;
      });

      shuffledWordList = randomFirst.concat(shuffledWordList);
    }

    let index = 0;

    retrievedWord = shuffledWordList[index];

    // Check novel word and has definitions available, is correct length and doesn't include spaces

    while (validateWord(retrievedWord, word)) {
      index++;

      if (index >= shuffledWordList.length) {
        throw new Error("no words were suitable");
      }

      if (!shuffledWordList[index]) {
        queryParams = "?".repeat(len);
        queryParams = queryParams.split("");

        index = 0;

        let count = 0;

        for (let k = 0; k < len; k++) {
          if (word.ref[k].contents !== "") {
            count++;
            queryParams[k] = word.ref[k].contents;
          }
        }

        if (count === 0) {
          queryParams[Math.floor(Math.random() * queryParams.length)] =
            common[Math.floor(Math.random() * common.length)];
        }

        queryParams = queryParams.join("");

        retrievedWordList = await getNewWord(queryParams);

        if (retrievedWordList.length === 0) {
          throw new Error("No words found");
        }

        if (difficultySetting === 1) {
          shuffledWordList = retrievedWordList.sort((a, b) => {
            return Math.random() > 5 ? 1 : -1;
          });
        } else {
          shuffledWordList = retrievedWordList.sort((a, b) => {
            return b.score - a.score;
          });

          let first = shuffledWordList.splice(
            0,
            Math.min(shuffledWordList.length, bufferAmount)
          );

          randomFirst = first.sort((a, b) => {
            return Math.random() > 0.5 ? 1 : -1;
          });

          shuffledWordList = randomFirst.concat(shuffledWordList);
        }
      }

      retrievedWord = shuffledWordList[index];
    }

    // Set across word

    const setWord = (retrievedWord, word) => {
      let clue = undefined;

      for (let a = 0; a < retrievedWord.defs.length; a++) {
        if (
          !retrievedWord.defs[a].split("\t")[1].includes(retrievedWord.word) &&
          !retrievedWord.defs[a]
            .split("\t")[1]
            .toLowerCase()
            .match(/sexual/)
        ) {
          clue = retrievedWord.defs[a].split("\t")[1];
          break;
        }
      }

      if (clue === undefined) {
        clue =
          retrievedWord.defs[
            Math.floor(Math.random() * retrievedWord.defs.length)
          ].split("\t")[1];

        let x = 0;

        while (clue.toLowerCase().match(/sexual/)) {
          x++;
          clue =
            retrievedWord.defs[
              Math.floor(Math.random() * retrievedWord.defs.length)
            ].split("\t")[1];

          if (x > 3) {
            throw new Error("no def suitable");
          }
        }
      }

      word.clue = clue;
      word.word = retrievedWord.word.split(" ").join("");
      allWords.push(retrievedWord.word.split(" ").join(""));

      let splitWord = word.word.split("");
      let len = splitWord.length;

      for (let l = 0; l < len; l++) {
        word.ref[l].contents = splitWord[l].toUpperCase();
      }
    };

    setWord(retrievedWord, word);

    //check for down word(s) needed in across word squares + add in down words using same method

    const findDownWords = async () => {
      for (let m = 0; m < word.ref.length; m++) {
        if (word.ref[m].downNumber !== "") {
          let downWord = words.down[`${word.ref[m].downNumber}down`];

          let count = 0;

          downWord.ref.forEach(async (square) => {
            square.contents === "" && count++;
          });

          if (count > 0) {
            let qParams = "?".repeat(downWord.ref.length);
            qParams = qParams.split("");

            downWord.ref.forEach((letter, index) => {
              if (letter.contents !== "") {
                qParams[index] = letter.contents.toLowerCase();
              }
            });

            qParams = qParams.join("");
            let downWordList = await getNewWord(qParams);

            if (downWordList.length === 0) {
              throw new Error("No words found");
            }

            let shuffledDownWordList = [];

            if (difficultySetting === 1) {
              shuffledDownWordList = downWordList.sort((a, b) => {
                return Math.random() > 0.5 ? 1 : -1;
              });
            } else {
              shuffledDownWordList = downWordList.sort((a, b) => {
                return b.score - a.score;
              });

              let first = shuffledDownWordList.splice(
                0,
                Math.min(shuffledDownWordList.length, bufferAmount)
              );

              randomFirst = first.sort((a, b) => {
                return Math.random() > 0.5 ? 1 : -1;
              });

              shuffledDownWordList = randomFirst.concat(shuffledDownWordList);
            }

            index = 0;
            let randomDownWord = shuffledDownWordList[index];

            // Check novel word and has definitions available, is correct length and doesn't include spaces

            while (validateWord(randomDownWord, downWord)) {
              if (index > shuffledDownWordList.length) {
                throw new Error("no words were suitable");
              }

              index++;

              if (!shuffledDownWordList[index]) {
                qParams = "?".repeat(len);
                qParams = qParams.split("");

                count = 0;

                for (let n = 0; n < len; n++) {
                  if (downWord.ref[n].contents !== "") {
                    count++;
                    qParams[n] = downWord.ref[n].contents;
                  }
                }

                qParams = qParams.join("");

                downWordList = await getNewWord(qParams);

                if (downWordList.length === 0) {
                  throw new Error("No words found");
                }

                if (difficultySetting === 1) {
                  shuffledDownWordList = downWordList.sort((a, b) => {
                    return Math.random() > 0.5 ? 1 : -1;
                  });
                } else {
                  shuffledDownWordList = downWordList.sort((a, b) => {
                    return b.score - a.score;
                  });

                  let first = shuffledDownWordList.splice(
                    0,
                    Math.min(shuffledDownWordList.length, bufferAmount)
                  );

                  randomFirst = first.sort((a, b) => {
                    return Math.random() > 0.5 ? 1 : -1;
                  });

                  shuffledDownWordList =
                    randomFirst.concat(shuffledDownWordList);
                }

                index = 0;
              }

              randomDownWord = shuffledDownWordList[index];
            }

            // set down word

            setWord(randomDownWord, downWord);
          }
        }
      }
    };

    await findDownWords();
  }

  const fillRemainingDownWords = async () => {
    allDownWords = Object.keys(words.down);

    for (let i = 0; i < allDownWords.length; i++) {
      let current = words.down[allDownWords[i]];

      if (current.ref[0].contents === "") {
        let query = "?".repeat(current.ref.length);
        query = query.split("");
        query[Math.floor(Math.random() * query.length)] =
          common[Math.floor(Math.random() * common.length)];
        query = query.join("");

        let newWordList = await getNewWord(query);

        if (newWordList.length === 0) {
          throw new Error("no words found");
        }

        let shuffledNewWordList = newWordList.sort((a, b) => {
          return Math.random() > 0.5 ? 1 : -1;
        });

        let index = 0;
        let finalNewWord = shuffledNewWordList[index];

        while (validateWord(finalNewWord, current)) {
          index++;
          if (index > shuffledWordList.length) {
            throw new Error("no words were suitable");
          }
          finalNewWord = shuffledNewWordList[index];
        }

        // set down word

        setWord(finalNewWord, current);
      }
    }
  };

  await fillRemainingDownWords();
  complete = true;

  populateCluesList();

  const overlay = document.querySelector(".modal");
  overlay.style.display = "none";
};

const populateCluesList = () => {
  let acrossCard = document.querySelector(".across-card");
  let downCard = document.querySelector(".down-card");

  let across = Object.keys(words.across);
  let down = Object.keys(words.down);

  let h = document.createElement("h3");
  h.textContent = "Across";
  acrossCard.append(h);

  let lineBreak = document.createElement("div");
  lineBreak.className = "line-break";
  acrossCard.append(lineBreak);

  across.forEach((val) => {
    let current = words.across[val];
    let p = document.createElement("p");
    p.innerHTML = `<strong>${val.replace("across", "")}</strong> ${
      current.clue
    } (${current.ref.length})`;
    acrossCard.append(p);
  });

  let h3 = document.createElement("h3");
  h3.textContent = "Down";
  downCard.append(h3);

  let lineBreakB = document.createElement("div");
  lineBreakB.className = "line-break";
  downCard.append(lineBreakB);

  down.forEach((val) => {
    let current = words.down[val];
    let p = document.createElement("p");
    p.innerHTML = `<strong>${val.replace("down", "")}</strong> ${
      current.clue
    } (${current.ref.length})`;
    downCard.append(p);
  });
};

createWordsAndClues();

const difficultySelect = (value) => {
  localStorage.setItem("difficulty", value);
  difficultySetting = parseInt(value);
};

difficulty.addEventListener("change", (e) => {
  difficultySelect(e.target.value);
  window.location.reload();
});

const reveal = document.querySelector(".reveal");

const revealGrid = () => {
  const allAcross = Object.keys(words.across);

  clearHighlight();

  let letterCount = 0;
  let entered = 0;
  let correct = 0;

  allSquares.forEach((cell) => {
    let row = cell.parentElement.id;
    let index = cell.cellIndex;
    let current = grid[`row${row}`][index];

    if (current.contents !== "#") {
      letterCount++;

      if (current.cell.children[1].textContent !== "") {
        entered++;
      }

      if (current.cell.children[1].textContent === current.contents) {
        correct++;
      }
    }
  });

  if (entered > 0 && correct !== letterCount) {
    allSquares.forEach((cell) => {
      let row = cell.parentElement.id;
      let index = cell.cellIndex;
      let current = grid[`row${row}`][index];

      if (
        current.contents !== "#" &&
        current.cell.children[1].textContent !== current.contents
      ) {
        current.cell.style.border = "2px solid red";
      }
    });
  }

  if (correct === letterCount) {
    let table = document.querySelector("table");
    table.style.border = "5px solid green";
    let message = document.querySelector(".message");
    message.style.display = "block";
  }

  allAcross.forEach((word) => {
    words.across[`${word}`].ref.forEach((cell, index) => {
      cell.cell.children[1].textContent =
        words.across[`${word}`].word[index].toUpperCase();
    });
  });

  const allDown = Object.keys(words.down);

  allDown.forEach((word) => {
    words.down[`${word}`].ref.forEach((cell, index) => {
      cell.cell.children[1].textContent =
        words.down[`${word}`].word[index].toUpperCase();
    });
  });

  reveal.removeEventListener("click", revealGrid);
};

reveal.addEventListener("click", revealGrid);

const newGrid = document.querySelector(".new");

newGrid.addEventListener("click", () => {
  window.location.reload();
});

let allSquares = Array.from(document.querySelectorAll("td"));

const clearHighlight = () => {
  allSquares.forEach((cell) => {
    cell.style.border = "1px solid black";
    if (cell.children[2]) {
      let target = cell.children[2];
      cell.children[1].textContent = target.value.toUpperCase();
      cell.removeChild(target);
    }
  });
};

allSquares.forEach((el) => {
  el.addEventListener("click", (e) => {
    let row = e.target.parentElement.id;
    let index = e.target.cellIndex;
    if (grid[`row${row}`][index].contents === "#") {
      clearHighlight();
      return;
    }
    highlightCells(e.target.parentElement.id, e.target.cellIndex);
  });
});

const highlightCells = (i, j) => {
  let current = grid[`row${i}`][j];
  let direction = "";
  let wordNumber = "";

  if (current.acrossNumber !== "") {
    direction = "across";
    wordNumber = current.acrossNumber;
  } else {
    direction = "down";
    wordNumber = current.downNumber;
  }

  let wordToHighlight = words[`${direction}`][`${wordNumber}${direction}`];

  if (
    wordToHighlight.ref[0].cell.style.border === "2px solid blue" &&
    wordToHighlight.ref[1].cell.style.border === "2px solid blue" &&
    current.acrossNumber !== "" &&
    current.downNumber !== ""
  ) {
    direction = "down";
    wordNumber = current.downNumber;
    wordToHighlight = words[`${direction}`][`${wordNumber}${direction}`];
  }

  clearHighlight();

  wordToHighlight.ref.forEach((cell, index) => {
    cell.cell.style.border = "2px solid blue";
    let target = cell.cell.children[1];
    let value = target.textContent;
    cell.cell.innerHTML += `<input class="input" type="text" maxlength="1" value="${value}" />`;
    cell.cell.children[1].textContent = "";
  });

  let inputs = Array.from(document.querySelectorAll(".input"));

  inputs.forEach((el, index) => {
    el.addEventListener("input", (e) => {
      if (e.inputType.includes("delete")) {
        return;
      }
      if (wordToHighlight.ref[index + 1]) {
        wordToHighlight.ref[index + 1].cell.children[2].select();
      }
    });
  });

  wordToHighlight.ref[0].cell.children[2].select();
};

    </script>
  </body>
</html>
